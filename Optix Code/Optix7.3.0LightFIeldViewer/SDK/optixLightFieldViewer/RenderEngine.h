#pragma once 
#include <glad/glad.h>  // Needs to be included before gl_interop
#include <optix.h>


#include <cuda_gl_interop.h>
#include <GLFW/glfw3.h>


#include <cuda_runtime.h>
#include <sutil/Camera.h>
#include <sutil/CUDAOutputBuffer.h>
#include "opencv2/core.hpp" 
#include "TextureDataTypes.h"
#include <map>

/// <summary>
/// Contains all basic datastructures needed for optix to function
/// including all modules and gas handle (for geometry)
/// </summary>
struct RenderState
{
    OptixDeviceContext          context = 0;
    OptixTraversableHandle      gas_handle = 0;
    CUdeviceptr                 d_gas_output_buffer = 0;

    OptixModule                 camera_module = 0;
    OptixModule                 geometry_module = 0;
    OptixModule                 shading_module = 0;

    OptixProgramGroup           raygen_prog_group = 0;
    OptixProgramGroup           miss_prog_group = 0;
    OptixProgramGroup           hitgroup_prog_group = 0;

    OptixPipeline               pipeline = 0;
    OptixPipelineCompileOptions pipeline_compile_options = {};

    CUstream                    stream = 0;
    whitted::LaunchParams       params = {};
    whitted::LaunchParams* d_params = 0;
    OptixShaderBindingTable     sbt = {};

    //Simple map to store textures object within the engine, based off the file they were inputted from
    std::map<std::string, std::shared_ptr<TextureBase>> texObjects;
};

/// <summary>
/// Large class which handles all pieces of the rendering process
/// contains many complex function used to generate optix 
/// </summary>
class RenderEngine
{
private:

    RenderState m_state;
    // The display buffer which contains the "view " generated by optix
    sutil::CUDAOutputBuffer<uchar4> m_output_buffer;

    typedef Record<EmptyData>    RayGenRecord;
    typedef Record<EmptyData>    MissRecord;
    typedef Record<HitGroupData> HitGroupRecord;

    /// <summary>
    /// Generates Camera program used by optix during rendering 
    /// </summary>
    /// <param name="program_groups"> program group to place this in</param>
    void RenderEngine::createCameraProgram(std::vector<OptixProgramGroup>& program_groups);

    /// <summary>
    /// Generates hit program used by optix during rendering 
    /// </summary>
    /// <param name="program_groups"> program group to place this in</param>
    void RenderEngine::createHitProgram(std::vector<OptixProgramGroup>& program_groups);

    /// <summary>
    /// Generates the miss program used by optix during rendering 
    /// </summary>
    /// <param name="program_groups"> program group to place this in</param>
    void RenderEngine::createMissProgram(std::vector<OptixProgramGroup>& program_groups);

    /// <summary>
    /// Creates the modules which link to cuda kernal functions to call during an optix render call
    /// </summary>
    void RenderEngine::createModules();

    /// <summary>
    /// builds the GAS uysed by optuix during rendering. this is the geometry acceleration structure and is used to store the geometry of the scene
    /// </summary>
    /// <param name="accel_options"></param>
    /// <param name="build_input"></param>
    /// <param name="gas_handle"></param>
    /// <param name="d_gas_output_buffer"></param>
    void RenderEngine::buildGas(const OptixAccelBuildOptions& accel_options,
        const OptixBuildInput& build_input,
        OptixTraversableHandle& gas_handle,
        CUdeviceptr& d_gas_output_buffer);

    static void RenderEngine::context_log_cb(unsigned int level, const char* tag, const char* message, void* /*cbdata */);

    /// <summary>
    /// Helper function used to automate geometry construction
    /// </summary>
    void RenderEngine::createGeometry();

    /// <summary>
    /// Helper function used to automate pipeline construction
    /// </summary>
    void RenderEngine::createPipeline();

    /// <summary>
    /// Helper function used to automate sbt construction
    /// </summary>
    void RenderEngine::createSBT();

    /// <summary>
    /// Helper function used to automate context construction
    /// </summary>
    void RenderEngine::createContext();


public:

    RenderEngine::RenderEngine();
    RenderEngine::RenderEngine(size_t w, size_t h);

    /// <summary>
    /// Method to load a given file onto the graphics card as a texture
    /// </summary>
    /// <param name="fileName"> string file name/path to open as texture ... expects either image formatted text ie: png, jpg etc or a text file containing lightfeild parameters</param>
    void RenderEngine::loadTexture(std::string fileName);

    /// <summary>
    /// Generates intial paramters used by to run optix
    /// </summary>
    /// <param name="outBuffType"> Type of output buffer to use, by default we use GL_INTEROPT but depending on contexts this should change</param>
    void RenderEngine::initLaunchParams();

    /// <summary>
    /// Given a camera object will update the renderer engines internal camera to represent the new position
    /// </summary>
    /// <param name="cam"> Camera object which contains eye parameter</param>
    void RenderEngine::handleCameraUpdate(sutil::Camera* cam);
    /// <summary>
    /// Will resize the output buffer to match the size of the window
    /// </summary>
    void RenderEngine::handleResize();

    /// <summary>
    /// Will build the optix engine given a default texture to display
    /// </summary>
    /// <param name="defaultTexture"> path which contains the default texture to show on the plane</param>
    void RenderEngine::buildEngine(std::string defaultTexture = "Config.txt");

    /// <summary>
    /// This is the rendering call which launchs all the rays to representing output pixels
    /// </summary>
    void RenderEngine::launchSubframe();
    /// <summary>
    /// This method will deconstruct the optix engine properly
    /// </summary>
    void RenderEngine::cleanupState();
    /// <summary>
    /// will replace th shown texture on the plane
    /// </summary>
    /// <param name="file">image to be used to replace the current texture</param>
    void RenderEngine::updateTexture(std::string file);

    void RenderEngine::setOutputBuffer(sutil::CUDAOutputBufferType bufType = sutil::CUDAOutputBufferType::CUDA_DEVICE, GLFWwindow* window = NULL)
    {
       //    std::cout << "Done FOR HERE11\n";
        glfwMakeContextCurrent(window);
        m_output_buffer.deletePBO();
        m_output_buffer = sutil::CUDAOutputBuffer<uchar4>(bufType, m_state.params.width, m_state.params.height);
        m_output_buffer.setStream(m_state.stream);
        //   std::cout << "Done FOR HERE\n";
    }


    //General utility functions

    /// <summary>
    /// Will load an image into the ram and return a pointer to it
    /// </summary>
    /// <param name="fileName"> Image to load</param>
    /// <returns> a mat object containg the image </returns>
    cv::Mat RenderEngine::loadImageToRam(std::string fileName);
    /// <summary>
    /// Simple code to check if a file has the extension .txt
    /// </summary>
    /// <param name="fileName"> filename to check</param>
    /// <returns> wheterht the file is .txt or not</returns>
    bool RenderEngine::is_textFile(std::string fileName);

    /// <summary>
    /// Gets Display width
    /// </summary>
    /// <returns></returns>
    size_t RenderEngine::GetDisplayWidth()  { return m_state.params.width; }

    /// <summary>
    /// Gets Display Height
    /// </summary>
    /// <returns></returns>
    size_t RenderEngine::GetDisplayHeight() { return m_state.params.height; }

    /// <summary>
    /// sets display dimensions
    /// </summary>
    /// <param name="w"> width </param>
    /// <param name="h"> height</param>
    void RenderEngine::setDisplayDimensions(size_t w, size_t h)
    {
        m_state.params.width = w;
        m_state.params.height = h;
    }

   
    /// <summary>
    /// Returns the stream optix is using
    /// </summary>
    /// <returns></returns>
    CUstream RenderEngine::GetStream() { return m_state.stream; }

    /// <summary>
    /// Returns a pointer to the render engines state
    /// </summary>
    /// <returns>pointer to the render engines state</returns>
    RenderState*  RenderEngine::GetState() { return &m_state; }

    /// <summary>
    /// Returns render engines output
    /// </summary>
    /// <returns>output buffer of optix</returns>
    sutil::CUDAOutputBuffer<uchar4>* RenderEngine::GetOutputBuffer() { return &m_output_buffer; }
};


